/**
 * Tidal Backup V2 - i18n (Korean / English)
 */
const I18n = {
    lang: 'ko',
    strings: {
        ko: {
            appTitle: 'Tidal Backup V2 ğŸ¤–',
            step1Title: '1ë‹¨ê³„: ì†ŒìŠ¤ (ë°±ì—…)',
            step2Title: '2ë‹¨ê³„: íƒ€ê²Ÿ (ë³µì›)',
            sourceDesc: 'ì¦ê²¨ì°¾ê¸°ë¥¼ ê°€ì ¸ì˜¬ ê³„ì •ì„ ì—°ê²°í•˜ì„¸ìš”.',
            targetDesc: 'ì¦ê²¨ì°¾ê¸°ë¥¼ ë³µì›í•  ê³„ì •ì„ ì—°ê²°í•˜ì„¸ìš”.',
            connectAccountA: 'ê³„ì • A ì—°ê²°',
            connectAccountB: 'ê³„ì • B ì—°ê²°',
            disconnect: 'ì—°ê²° í•´ì œ',
            refresh: 'ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°',
            waiting: 'ëŒ€ê¸° ì¤‘...',
            openTidalLogin: 'Tidal ë¡œê·¸ì¸ ì—´ê¸°',
            connected: 'ì—°ê²°ë¨',
            transferTitle: 'ê³„ì • ê°„ ì´ì „',
            startTransfer: 'ì´ì „ ì‹œì‘ â–¶',
            backupRestoreTitle: 'ë°±ì—… / ë³µì› (JSON)',
            backupRestoreDesc: 'ì¦ê²¨ì°¾ê¸°ë¥¼ JSONìœ¼ë¡œ ë‹¤ìš´ë¡œë“œí•˜ê±°ë‚˜ íŒŒì¼ì—ì„œ ë³µì›í•˜ì„¸ìš”.',
            downloadJson: 'JSON ë‹¤ìš´ë¡œë“œ',
            restoreFromJson: 'JSONì—ì„œ ë³µì›',
            transferStatus: 'ì´ì „ ìƒíƒœ',
            initializing: 'ì´ˆê¸°í™” ì¤‘...',
            transferComplete: 'ì´ì „ ì™„ë£Œ!',
            restoreComplete: 'ë³µì› ì™„ë£Œ!',
            footer: 'API í‚¤ ë¶ˆí•„ìš” Â· 100% í´ë¼ì´ì–¸íŠ¸ Â· python-tidal ê¸°ë°˜',
            settings: 'ì„¤ì • âš™ï¸',
            clientIdPreset: 'Client ID í”„ë¦¬ì…‹',
            clientIdHelp: 'Tidalì´ IDë¥¼ revokeí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ì€ ë˜ëŠ”ë° ì¦ê²¨ì°¾ê¸°ê°€ 403ì´ë©´ <a href="https://developer.tidal.com/dashboard" target="_blank" rel="noopener">developer.tidal.com</a>ì—ì„œ ë“±ë¡ í›„ ë³¸ì¸ Client IDë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.',
            manualToken: 'ìˆ˜ë™ Access Token (ë¹„ìƒìš©)',
            manualTokenPlaceholder: 'access_tokenì„ ì—¬ê¸°ì— ë¶™ì—¬ë„£ê¸°',
            manualTokenHelp: 'ìë™ ë¡œê·¸ì¸ì´ ë°˜ë³µ ì‹¤íŒ¨í•  ë•Œë§Œ ì‚¬ìš©í•˜ì„¸ìš”.',
            saveClose: 'ì €ì¥ í›„ ë‹«ê¸°',
            tracks: 'ê³¡',
            artists: 'ì•„í‹°ìŠ¤íŠ¸',
            albums: 'ì•¨ë²”',
            playlists: 'í”Œë ˆì´ë¦¬ìŠ¤íŠ¸',
            help: '?',
            usageTitle: 'ì‚¬ìš©ë²•',
            usageSteps: '<ol class="usage-steps"><li>ì™¼ìª½ì—ì„œ ë°±ì—…í•  ê³„ì •(ì†ŒìŠ¤) ì—°ê²°</li><li>ì˜¤ë¥¸ìª½ì—ì„œ ë³µì›í•  ê³„ì •(íƒ€ê²Ÿ) ì—°ê²°</li><li>ì´ì „í•  í•­ëª© ì„ íƒ í›„ <strong>ì´ì „ ì‹œì‘</strong> í´ë¦­</li><li><strong>ëŒ€ì•ˆ</strong>: JSON ë‹¤ìš´ë¡œë“œë¡œ ë°±ì—… â†’ ë‚˜ì¤‘ì— JSONì—ì„œ ë³µì›</li></ol>',
            langKo: 'í•œê¸€',
            langEn: 'English',
            loginFailed: 'ë¡œê·¸ì¸ ì‹¤íŒ¨',
            nothingToTransfer: 'ì´ì „í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.',
            transferringItems: '{n}ê°œ ì´ì „ ì¤‘...',
            moved: 'ì´ë™:',
            failed: 'ì‹¤íŒ¨:',
            done: 'ì™„ë£Œ! ğŸ‰',
            connectTargetFirst: 'íƒ€ê²Ÿ ê³„ì •ì„ ë¨¼ì € ì—°ê²°í•˜ì„¸ìš”.',
            noItemsInFile: 'íŒŒì¼ì— í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.',
            restoringFromJson: '{n}ê°œ JSONì—ì„œ ë³µì› ì¤‘...',
            added: 'ì¶”ê°€:',
            invalidJson: 'ì˜ëª»ëœ JSON',
            copyReport: 'ì‹¤íŒ¨ ë¦¬í¬íŠ¸ ë³µì‚¬',
            reportCopied: 'í´ë¦½ë³´ë“œì— ë³µì‚¬ë¨',
            targetService: 'ëŒ€ìƒ ì„œë¹„ìŠ¤',
            connectQobuz: 'Qobuz ì—°ê²°',
            qobuzLoginDesc: 'Qobuz ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.',
            email: 'ì´ë©”ì¼',
            password: 'ë¹„ë°€ë²ˆí˜¸',
            login: 'ë¡œê·¸ì¸',
            connectSpotify: 'Spotify ì—°ê²°',
            spotifyLoginDesc: 'Spotify ê³„ì •ì„ ì—°ê²°í•˜ì„¸ìš”.',
            searching: 'ê²€ìƒ‰ ì¤‘...',
            searchingFor: 'Qobuzì—ì„œ ê²€ìƒ‰ ì¤‘: {name}',
            searchingSpotify: 'Spotifyì—ì„œ ê²€ìƒ‰ ì¤‘: {name}',
            matching: 'ë§¤ì¹­ ì¤‘...',
            noMatch: 'ë§¤ì¹­ ì‹¤íŒ¨',
            matchFound: 'ë§¤ì¹­ ì„±ê³µ',
        },
        en: {
            appTitle: 'Tidal Backup V2 ğŸ¤–',
            step1Title: 'Step 1: Source (Backup)',
            step2Title: 'Step 2: Target (Restore)',
            sourceDesc: 'Connect the account you want to copy FROM.',
            targetDesc: 'Connect the account you want to copy TO.',
            connectAccountA: 'Connect Account A',
            connectAccountB: 'Connect Account B',
            disconnect: 'Disconnect',
            refresh: 'Refresh',
            waiting: 'Waiting...',
            openTidalLogin: 'Open Tidal Login',
            connected: 'Connected',
            transferTitle: 'Transfer Between Accounts',
            startTransfer: 'Start Transfer â–¶',
            backupRestoreTitle: 'Backup / Restore (JSON)',
            backupRestoreDesc: 'Download favorites as JSON or restore from file.',
            downloadJson: 'Download JSON',
            restoreFromJson: 'Restore from JSON',
            transferStatus: 'Transfer Status',
            initializing: 'Initializing...',
            transferComplete: 'Transfer Complete!',
            restoreComplete: 'Restore Complete!',
            footer: 'No API Key Needed Â· 100% Client-side Â· Based on python-tidal',
            settings: 'Settings âš™ï¸',
            clientIdPreset: 'Client ID Preset',
            clientIdHelp: 'Tidal may revoke IDs. If login succeeds but favorites show 403, register at <a href="https://developer.tidal.com/dashboard" target="_blank" rel="noopener">developer.tidal.com</a> and use your Client ID.',
            manualToken: 'Manual Access Token (Emergency)',
            manualTokenPlaceholder: 'Paste access_token here',
            manualTokenHelp: 'Only use if automatic login fails repeatedly.',
            saveClose: 'Save & Close',
            tracks: 'Tracks',
            artists: 'Artists',
            albums: 'Albums',
            playlists: 'Playlists',
            help: '?',
            usageTitle: 'Usage',
            usageSteps: '<ol class="usage-steps"><li>Connect source account (left panel) to copy FROM</li><li>Connect target account (right panel) to copy TO</li><li>Select items to transfer and click <strong>Start Transfer</strong></li><li><strong>Alternative</strong>: Download JSON to backup â†’ Restore from JSON later</li></ol>',
            langKo: 'í•œê¸€',
            langEn: 'English',
            loginFailed: 'Login Failed',
            nothingToTransfer: 'Nothing to transfer.',
            transferringItems: 'Transferring {n} items...',
            moved: 'Moved:',
            failed: 'Failed:',
            done: 'Done! ğŸ‰',
            connectTargetFirst: 'Connect Target account first.',
            noItemsInFile: 'No items in file.',
            restoringFromJson: 'Restoring {n} items from JSON...',
            added: 'Added:',
            invalidJson: 'Invalid JSON',
            copyReport: 'Copy failure report',
            reportCopied: 'Copied to clipboard',
            targetService: 'Target Service',
            connectQobuz: 'Connect Qobuz',
            qobuzLoginDesc: 'Enter your Qobuz email and password.',
            email: 'Email',
            password: 'Password',
            login: 'Login',
            connectSpotify: 'Connect Spotify',
            spotifyLoginDesc: 'Connect your Spotify account.',
            searching: 'Searching...',
            searchingFor: 'Searching on Qobuz: {name}',
            searchingSpotify: 'Searching on Spotify: {name}',
            matching: 'Matching...',
            noMatch: 'No match found',
            matchFound: 'Match found',
        }
    },

    init() {
        this.lang = localStorage.getItem('tidal_v2_lang') || (navigator.language.startsWith('ko') ? 'ko' : 'en');
        document.documentElement.lang = this.lang === 'ko' ? 'ko' : 'en';
    },

    t(key, vars = {}) {
        let s = this.strings[this.lang]?.[key] ?? this.strings.en?.[key] ?? key;
        Object.keys(vars).forEach((k) => { s = s.replace(`{${k}}`, vars[k]); });
        return s;
    },

    setLang(lang) {
        this.lang = lang;
        localStorage.setItem('tidal_v2_lang', lang);
        document.documentElement.lang = lang === 'ko' ? 'ko' : 'en';
        this.apply();
    },

    apply() {
        document.querySelectorAll('[data-i18n]').forEach((el) => {
            const key = el.getAttribute('data-i18n');
            const val = this.t(key);
            if (el.hasAttribute('data-i18n-html')) {
                el.innerHTML = val;
            } else if (el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA') {
                el.textContent = val;
            }
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach((el) => {
            el.placeholder = this.t(el.getAttribute('data-i18n-placeholder'));
        });
        document.title = this.t('appTitle');
    }
};
